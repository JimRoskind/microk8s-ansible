---
#  Command will sometimes fail due to timeout, as snap takes a while.
#  The good news is that it typically makes incremental progress, and will
#  eventually succeed.  I should figure out how to adjust the timeout
#  for the running of the underlying shell command.
#  When this command completes, the nodes will be running "singleton"
#  kubernetes clusters, and must still be "joined" together into a
#  larger cluster.
- hosts: all
  become: yes




  tasks:
      # Raspian puts cmdline.txt in /boot/., while ubuntu has /boot/firmware/.
      # Note that there is no such directory on Raspian
    - name: Detect presence of Ubuntu directory /boot/firmware
      stat:
        path: /boot/firmware/cmdline.txt
      register: firmware_cmdline

    - name: Tentatiely indicate where to find cmdline.txt file.
      set_fact:
        cmdline_file_path: /boot/cmdline.txt

    - name: Optionally correct to indicate ubuntu location
      set_fact:
        cmdline_file_path: /boot/firmware/cmdline.txt
      when:
        - firmware_cmdline.stat.exists

    # I could use the lookup('ansible.bulitin.csvfile', 'memory file=/proc/cgroups delimeter=" " col=4 default=0')
    - name: Check to see if cgroup_memory is already enabled
      lineinfile:
        path: /proc/cgroups
        regex: '^memory\t.*\t1$'
        state: present
        line: "If there would be a change, then we have cgroup_memory enabled"
      check_mode: yes
      register: mem_cgroup_present

    - name: Prepare to read in cmdline.txt (and be ready to verify it exists.
      stat:
        path: "{{ cmdline_file_path }}"
      register: cmdline_file
      when:
        - not mem_cgroup_present.changed

    - name: Read in cmdline.txt
      command:
        cmd: "cat {{ cmdline_file_path }}"
      register: cmdline_contents
      changed_when: false
      when:
        - not mem_cgroup_present.changed
        - cmdline_file.stat.exists

    - name: Augment cmdline.txt with options if necessary
      lineinfile:
        path: "{{ cmdline_file_path }}"
        regex: '^(.*)'
        line: '\1 {{ option }}'
        backrefs: true
      loop_control:
        loop_var: option
        label: "{{ option }}"
      loop:
        - cgroup_enable=memory
        - cgroup_memory=1
      when:
        - not mem_cgroup_present.changed
        - cmdline_file.stat.exists
        - option not in cmdline_contents.stdout
      register: cmdline_file_edit

    - name: Reboot if boot option changed
      reboot:
      when:
        - cmdline_file_edit.changed

    - name: Validate cgroup_memory was really set
      lineinfile:
        path: /proc/cgroups
        regex: '^memory\t.*\t1$'
        state: absent
      check_mode: yes
      when:
        - not mem_cgroup_present.changed
      register: mem_cgroup_finally_present

    - name: Assert that cgroup_memory was really found (enabled) now
      assert:
        that:
          - false
        fail_msg: >
          "Append to /boot/firmware/cmdline.txt the commands
          cgroup_enable=memory cgroup_memory=1"
      when:
        - not mem_cgroup_finally_present.skipped
        - not mem_cgroup_finally_present.changed

    - name: Ensure that snap is available
      apt:
        name: snapd
        state: latest
      register: snapd_installation

    - name: Reboot if snapd was installed
      reboot:
        reboot_timeout: 90
      when:
        - snapd_installation.changed

    - name: Ensure snapd is running
      service:
        name: snapd
        state: started
        enabled: true
      register: snapd_running

    - name: Install snap core if we did an install of snap
      snap:
        name: core
        state: present

    - name: Snap install of microk8s
      # If this fails with a timeout... just try again <sigh>
      snap:
        name: microk8s
        classic: true
        state: present

    # To avoid needing to sudo for microk8s commands, we add this user
    # to the required group.
    - name: Add user to microk8s group
      user:
        name: "{{ ansible_user }}"
        groups: microk8s
        append: yes

    - name: Hack workaround for problem in delegate_to
      # It always assumes that python is found in the SAME place on the delegated host,
      # which is commonly /usr/bin/python.  The hack is to link that host name to
      # the available python3 if the file is not present.
      # Ubuntu has /usr/bin/python, but Raspian only has /usr/bin/python3
      stat:
        path: /usr/bin/python
      register: python2_executable

    - name: Optionally install the link so that delegate can work :-/
      # This is a hack to cover for the (current) fact that delegation
      # between Raspian nodes and Ubuntu nodes won't quite work, since
      # Raspian didn't bother to include anything as user/bin/python.
      # We need this when we join nodes, because we delegate to get
      # new add node commands, and to get a list of existing nodes.
      file:
        dest: /usr/bin/python
        src: /usr/bin/python3
        state: link
        owner: root
        group: root
        mode: '0755'
      when:
        - not python2_executable.stat.exists

...
